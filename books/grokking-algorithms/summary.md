# Грокаем алгоритмы

## Глава 1 Знакомство с алгоритмами

* Бинарный поиск - это алгоритм; на входе он получает отсортированный
список элементов (позднее я объясню, почему он должен быть отсортиро­
ван). Если элемент, который вы ищете, присутствует в списке, то бинарный
поиск возвращает ту позицию, в которой он был найден. В противном слу­
чае бинарный поиск возвращает null.

* Ниже перечислены пять разновидностей о-большого в порядке убывания скорости выполнения :

| Формула                             | Пример                                                         |
| ----------------------------------- | -------------------------------------------------------------- |
| O(log n) или логарифмическое время. | Пример: бинарный поиск.                                        |
| О(n) или линейное время.            | Пример: простой поиск.                                         |
| O(n * log n)                        | Пример: эффективные алгоритмы сортировки (быстрая сортировка). |
| О(n ** 2)                           | Пример: медленные алгоритмы сортировки (сортировка выбо­ром).  |
| О(n!)                               | Пример: очень медленные алгоритмы (задача о коммивояжере).     |

* Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операции.
* По сути формула описывает, насколько быстро возрастает время выпол­нения алгоритма с увеличением размера входных данных.
* Время выполнения алгоритмов выражается как O-большое.
* Время выполнения O(log n) быстрее О(n), а с увеличением размера списка, в котором ищется значение, оно становится намного быстрее.

## Глава 2 Сортировка выбором

* Память компьютера напоминает огромный шкаф с ящиками.
* Если вам потребуется сохранить набор элементов, воспользуйтесь мас­
сивом или списком.
* В массиве все элементы хранятся в памяти рядом друг с другом.
* В списке элементы распределяются в произвольных местах памяти , при
этом в одном элементе хранится адрес следующего элемента.
* Массивы обеспечивают быстрое чтение.
* Списки обеспечивают быструю вставку и выполнение.
* Все элементы массива должны быть однотипными (только целые числа,
только вещественные числа и т. д.).

## Глава 3 Рекурсия

* Когда функция вызывает саму себя, это называется рекурсиеи.
* В каждой рекурсивной функции должно быть два случая: базовый и рекурсивный.
* Стек поддерживает две операции: занесение и извлечение элементов.
* Все вызовы функций сохраняются в сте­ке вызовов.
* Если стек вызовов памяти станет очень большим, он займет слишком много памяти.

## Глава 4 Быстрая сортировка

* Стратегия "разделяйи властвуи" основана н а разбиении задачи на уменьшающиеся фрагменты. Если вы используете стратегию "разделя и и властвуй" со списком, то базовым случаем , скорее всего, я вляется
пустои массив или массив из одного элемента.
* Если вы реализуете алгоритм быстрой сортировки, выберите в качестве
опорного случайный элемент. Среднее время выполнения быстрой сор­
тировки составляет О(n log n)!
* Константы в "о-большом" иногда могут иметь значение. Именно по
этой причине быстрая сортировка быстрее сортировки слиянием.
* При сравнении простой сортировки с бинарной константа почти никогда
роли не играет, потому что O(log n) слишком сильно превосходит О(n)
по скорости при большом размере списка.

## Глава 5 Хеш-таблицы

* Хеш-функция должна соответствовать некоторым требованиям:
1. Она должна быть последовательной . Допустим , вы передали ей строку "апельсины" и получ или 4. Это значит, что каждый раз в будущем, передавая ей строку "апельсины", вы будете получать 4. Без этого хеш­-таблица бесполезна.
1. Разным словам должны соответствовать разные числа. Например, хеш­
функция, которая возвращает 1 для каждого полученного слова, никуда
не годится. В идеале каждое входное слово должно отображаться на свое
число.
1. Хеш-функция знает размер массива и возвращает только действитель­
ные индексы. Таким образом, если длина массива равна 5 элементам,
хеш-функция не вернет 100, потому что это значение не является дей­
ствительным индексом в массиве.
* Хеш-таблица состоит из ключей и значений.
* Хеши хорошо подходят для решения следующих задач:
1. моделирование отношений между объектами
2. устранение дубликатов;
3. кэширование/запоминание данных вместо выполнения работы на сер­вере.
* Выбор хеш-функции действительно важен. Хеш-функция, отображаю­
щая все ключи на один элемент массива, никуда не годится. В идеале
хеш-функция должна распределять ключи равномерно по всему хешу;
* Если связанные списки становятся слишком длинными, работа с
хеш-таблицей сильно замедляется. Но они не станут слишком длинными при
использовании хорошей хеш-функции!
* Хеш-таблица создается объединением хеш-функции с массивом.
Коллизии нежелательны. Хеш-функция должна свести количество коллизии к минимуму.
* Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки
и удаления.
* Хеш-таблицы хорошо подходят для моделирования отношений между
объектами.
* Как только коэффициент заполнения превышает 0.7 пора изменять раз­
мер хеш-таблицы.
* Хеш-таблицы используются для кэширования данных (например, на
веб-серверах).
* Хеш-таблицы хорошо подходят для обнаружения дубликатов.

## Глава 6 Поиск в ширину

* Поиск в ширину позволяет определить, существует ли путь из А в В.
* Если путь существует, то поиск в ширину находит кратчайший путь.
* Если в вашей задаче требуется найти "кратчайшее х", попробуйте смоделировать свою задачу графом и воспользуйтесь поиском в ширину для ее решения.
* В направленном графе есть стрелки, а отношения действуют в направлении стрелки (Рама -> Адит означает Рама должен Адиту).
* В ненаправленных графах стрелок нет, а отношение идет в обе стороны
(Росс - Рэйчел означает Росс встречается с Рэйчел, а Рэйчел встреча­ется с Россо)
* Очереди относятся к категории FIFO ("первым вошел, первым вышел").
* Стек относится к категории LIFO ("последним пришел, первым вышел").
* Л юдей следует проверять в порядке их добавления в список поиска, поэтому
список поиска должен быть оформлен в виде очереди, иначе наиденныи путь
не будет кратчайшим.
* Позаботьтесь о том, чтобы уже праве ренныи человек не проверялся заново, иначе может возникнуть бесконечный цикл.

## Глава 7 Алгоритм Дейкстры

* Алгоритм Дейкстры состоит из четырех шагов:
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно
добраться за минимальное время ).
1. Проверить, существует ли более дешевый путь к соседям этого узла,
и если существует, обновить их стоимости.
1. Повторять, пока это не будет сделано для всех узлов графа.
1. Вычислить итоговый путь.
   
* Поиск в ширину вычисляет кратчайший путь в невзвешенном графе.
* Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе.
* Алгоритм Дейкстры работает только в том случае, если все веса поло­жительны.
* При наличии отрицательных весов используйте алгоритм Беллмана­-Форда.

## Глава 8 Жадные алгоритмы

* NР-полные задачи встречаютс я очень часто. И было бы полезно, если бы
вы могли понять, что решаемая задача является NР-полной. В этот момент
можно прекратить поиски идеального решения и переити к решению с при-
менением приближенного алгоритма. Признаки NP-полной задачи:
1. ваш алгоритм быстро работает при малом количестве элементов, но
сильно замедляется при увеличении их числа
1. формулировка "все комбинации х" часто указывает на NР-полноту за­дачи
1. вам приходится вычислять все возможные варианты Х, потому что за­дачу невозможно разбить на меньшие подзадачи? Такая задача может оказаться NР-полной
1. если в задаче встречается некоторая последовательность (например,
последовательность городов, как в задаче о коммивояжере) и задача не
имеет простого решения, она может оказаться NР-полной
1. если в задаче встречается некоторое множество (например, множество
радиостанций) и задача не имеет простого решения, она может оказаться
NР-полной
1. можно ли переформулировать задачу в условиях задачи покрытия
множества или задачи о коммивояжере? В таком случае ваша задача
определено является NР-полной.

* Жадные алгоритмы стремятся к локальной оптимизации в расчете на то,
что в итоге будет достигнут глобальный оптимум.
* У NР-полных задач не существует известных быстрых решений.
* Если у вас имеется NР-полная задача, лучше всего воспользоваться при­ближенным алгоритмом.
* Жадные алгоритмы легко реализуются и быстро выполняются, поэтому
из них получаются хорошие приближенные алгоритмы.

* Множества:
1. Объединение множеств означает слияние элементов обоих множеств.
1. Под операцией пересечения множеств понимается поиск элементов,
входящих в оба множества.
1. Под разностью множеств понимается исключение из одного множества
элементов, присутствующих в другом множестве.
1. Множества похожи на списки, но множества не содержат дубликатов.

## Глава 9 Динамическое программирование

* Динамическое программирование применяется при оптимизации некоторой характеристики.
* Динамическое программирование работает только в ситуациях, в кото­рых задача может быть разбита на автономные подзадачи.
* В каждом решении из области динамического программирования стро­ится таблица.
* Значения ячеек таблицы обычно соответствуют оптимизируемой харак­теристике.
* Каждая ячейка представляет подзадачу, поэтому вы должны подумать о том, как разбить задачу на подзадачи.
* Не существует единой формулы для вычисления решений методом ди­намического программирования.


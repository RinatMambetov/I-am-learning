# Грокаем алгоритмы

## Глава 1 Знакомство с алгоритмами

* Бинарный поиск - это алгоритм; на входе он получает отсортированный
список элементов (позднее я объясню, почему он должен быть отсортиро­
ван). Если элемент, который вы ищете, присутствует в списке, то бинарный
поиск возвращает ту позицию, в которой он был найден. В противном слу­
чае бинарный поиск возвращает null.

* Ниже перечислены пять разновидностей о-большого в порядке убывания скорости выполнения :

| Формула                             | Пример                                                         |
| ----------------------------------- | -------------------------------------------------------------- |
| O(log n) или логарифмическое время. | Пример: бинарный поиск.                                        |
| О(n) или линейное время.            | Пример: простой поиск.                                         |
| O(n * log n)                        | Пример: эффективные алгоритмы сортировки (быстрая сортировка). |
| О(n ** 2)                           | Пример: медленные алгоритмы сортировки (сортировка выбо­ром).  |
| О(n!)                               | Пример: очень медленные алгоритмы (задача о коммивояжере).     |

* Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операции.
* По сути формула описывает, насколько быстро возрастает время выпол­нения алгоритма с увеличением размера входных данных.
* Время выполнения алгоритмов выражается как O-большое.
* Время выполнения O(log n) быстрее О(n), а с увеличением размера списка, в котором ищется значение, оно становится намного быстрее.

## Глава 2 Сортировка выбором

* Память компьютера напоминает огромный шкаф с ящиками.
* Если вам потребуется сохранить набор элементов, воспользуйтесь мас­
сивом или списком.
* В массиве все элементы хранятся в памяти рядом друг с другом.
* В списке элементы распределяются в произвольных местах памяти , при
этом в одном элементе хранится адрес следующего элемента.
* Массивы обеспечивают быстрое чтение.
* Списки обеспечивают быструю вставку и выполнение.
* Все элементы массива должны быть однотипными (только целые числа,
только вещественные числа и т. д.).

## Глава 3 Рекурсия

* Когда функция вызывает саму себя, это называется рекурсиеи.
* В каждой рекурсивной функции должно быть два случая: базовый и рекурсивный.
* Стек поддерживает две операции: занесение и извлечение элементов.
* Все вызовы функций сохраняются в сте­ке вызовов.
* Если стек вызовов памяти станет очень большим, он займет слишком много памяти.

## Глава 4 Быстрая сортировка

* Стратегия "разделяйи властвуи" основана н а разбиении задачи на уменьшающиеся фрагменты. Если вы используете стратегию "разделя и и властвуй" со списком, то базовым случаем , скорее всего, я вляется
пустои массив или массив из одного элемента.
* Если вы реализуете алгоритм быстрой сортировки, выберите в качестве
опорного случайный элемент. Среднее время выполнения быстрой сор­
тировки составляет О(n log n)!
* Константы в "о-большом" иногда могут иметь значение. Именно по
этой причине быстрая сортировка быстрее сортировки слиянием.
* При сравнении простой сортировки с бинарной константа почти никогда
роли не играет, потому что O(log n) слишком сильно превосходит О(n)
по скорости при большом размере списка.

##